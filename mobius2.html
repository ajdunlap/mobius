<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Möbius Strip</title>
    <style type="text/css">p,label { font-family: "Arial", "Liberation Sans", sans-serif; }</style>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="js/three.min.js"></script>

  <script type="text/javascript">
    function setup () {
      var width = 800;
      var height = 600;
  
      var scene = new THREE.Scene();
  
      var theta = 0;
      var camera = new THREE.PerspectiveCamera (3, width/height, 0.1, 5000);
      function positionCamera () {
        camera.position.z = 800*Math.cos(theta);
        camera.position.x = 800*Math.sin(theta);
        camera.position.y = 0;
        camera.lookAt(new THREE.Vector3(0,0,0));
      }
      positionCamera();
  
      var renderer = new THREE.WebGLRenderer();
      renderer.sortObjects = false;
      renderer.setSize(width,height);
      document.getElementById('animation-space').appendChild(renderer.domElement);

      var light = new THREE.AmbientLight( 0x404040 ); // soft white light
      scene.add( light );

      // Set up the light source
      var pointLight = new THREE.PointLight(0xFFFFFF);
      pointLight.position.x = 0;
      pointLight.position.y = 0;
      pointLight.position.z = 3000;
      scene.add(pointLight);
      var pointLight2 = new THREE.PointLight(0xFFFFFF);
      pointLight2.position.x = 0;
      pointLight2.position.y = 0;
      pointLight2.position.z = 0;
      scene.add(pointLight2);
      var pointLight3 = new THREE.PointLight(0xFFFFFF);
      pointLight3.position.x = 0;
      pointLight3.position.y = 0;
      pointLight3.position.z = -3000;
      scene.add(pointLight3);

      var L = 101;

      function wrapBetween (L, geom, topVs, bottomVs) {
        geom.morphTargets = [];
        vertices = geom.vertices.slice();
        for (var i = 0 ; i < L ; ++i) {
          if (i == 0) {
            vertices[i] = topVs[i];
            vertices[i+L] = bottomVs[i];
          } else {
            for (j = 0 ; j < 2*L ; ++j) {
              vertices[j] = vertices[j].clone();
            }
            var B = new THREE.Matrix4();
            var u = vertices[i];
            var v = vertices[i+L];
            var w = vertices[i-1];
            var uu = topVs[i];
            var vv = bottomVs[i];
            var ww = topVs[i-1].clone();
            ww.sub(uu);
            ww.multiplyScalar(0.3);
            ww.add(uu);
            var A = new THREE.Matrix4(v.x-u.x,w.x-u.x,Math.random(),0,
                                      v.y-u.y,w.y-u.y,Math.random(),0,
                                      v.z-u.z,w.z-u.z,Math.random(),0,
                                      0,0,0,1
                                      );
            var B = new THREE.Matrix4(vv.x-uu.x,ww.x-uu.x,Math.random(),0,
                                      vv.y-uu.y,ww.y-uu.y,Math.random(),0,
                                      vv.z-uu.z,ww.z-uu.z,Math.random(),0,
                                      0,0,0,1
                                      );
            var Ainv = new THREE.Matrix4();
            Ainv.getInverse(A);
            var C = new THREE.Matrix4();
            C.multiplyMatrices(B,Ainv);
            var uuu = u.clone();
            uuu.applyMatrix4(C);
            var D = new THREE.Matrix4();
            D.makeTranslation(uu.x-uuu.x,uu.y-uuu.y,uu.z-uuu.z);
            var E = new THREE.Matrix4();
            E.multiplyMatrices(D,C);
  
            for (var j = i ; j < L ; ++j) {
              vertices[j].applyMatrix4(E);
              vertices[j+L].applyMatrix4(E);
            }
          }
          geom.morphTargets[i] = {name:'v'+i,vertices:vertices.slice()};
        }
      }

      var topVs = [];
      var bottomVs = [];
      var midVs = [];
      for (var j = 0 ; j < L ; ++j) {
        var r = 10-2.5*Math.cos(Math.PI*j/(L-1));
        var R = 10+2.5*Math.cos(Math.PI*j/(L-1));
        topVs[j] = new THREE.Vector3(R*Math.cos(2*Math.PI*j/(L-1)),
                                     R*Math.sin(2*Math.PI*j/(L-1)),
                                     2.5*Math.sin(Math.PI*j/(L-1)));
        bottomVs[j] = new THREE.Vector3(r*Math.cos(2*Math.PI*j/(L-1)),
                                        r*Math.sin(2*Math.PI*j/(L-1)),
                                        -2.5*Math.sin(Math.PI*j/(L-1)));
        var tmp = topVs[j].clone();
        tmp.multiplyScalar(1-j/(L-1));
        midVs[j] = bottomVs[j].clone();
        midVs[j].multiplyScalar(j/(L-1));
        midVs[j].add(tmp);
      }

      var topG = new THREE.Geometry();
      topG.vertices = topVs;
      var topM = new THREE.LineBasicMaterial({color:0xFF0000,linewidth:4});
      var topp = new THREE.Line(topG,topM);
      //scene.add(topp);

      var bottomG = new THREE.Geometry();
      bottomG.vertices = bottomVs;
      var bottomM = new THREE.LineBasicMaterial({color:0x00FF00,linewidth:4});
      var bottom = new THREE.Line(bottomG,bottomM);
      //scene.add(bottom);

      var midG = new THREE.Geometry();
      midG.vertices = midVs;
      var midM = new THREE.LineBasicMaterial({color:0x0000FF,linewidth:4});
      var mid = new THREE.Line(midG,midM);
      //scene.add(mid);

      var stripCutG = new THREE.Geometry();
      stripCutG.vertices = [new THREE.Vector3(-10,0,2.5),new THREE.Vector3(-10,0,-2.5)];
      var stripCutM = new THREE.LineBasicMaterial({color:0xFF0000,linewidth:4});
      var stripCut = new THREE.Line(stripCutG,stripCutM);
      scene.add(stripCut);

      /*
      var stripG = new THREE.PlaneGeometry(20,5,L-1);
      wrapBetween(L,stripG,topVs,bottomVs);
      var stripM = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x111166,morphTargets:true} );
      var strip = new THREE.MorphAnimMesh(stripG,stripM);
      strip.setFrameRange(2,L-1);
      strip.mirroredLoop = true;
      strip.duration = 100;
      strip.morphTargetInfluences = [];
      //for (var j = 0 ; j < L ; ++j) {
        //strip.morphTargetInfluences[j] = 0;
      //}
      scene.add(strip);
      */

      var strip1G = new THREE.PlaneGeometry(10,5,(L-1)/2);
      wrapBetween((L+1)/2,strip1G,topVs.slice(0,(L+1)/2),bottomVs.slice(0,(L+1)/2));
      var strip1M = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0xFF1166,morphTargets:true} );
      var strip1 = new THREE.MorphAnimMesh(strip1G,strip1M);
      strip1.setFrameRange(2,(L+1)/2-1);
      strip1.mirroredLoop = true;
      strip1.duration = 100;
      scene.add(strip1);

      var strip2G = new THREE.PlaneGeometry(10,5,(L-1)/2);
      var tvsR = topVs.slice(L/2);
      tvsR.reverse();
      var bvsR = bottomVs.slice(L/2);
      bvsR.reverse();
      wrapBetween((L+1)/2,strip2G,tvsR,bvsR);
      var strip2M = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0xFF1166,morphTargets:true} );
      var strip2 = new THREE.MorphAnimMesh(strip2G,strip2M);
      strip2.setFrameRange(2,(L+1)/2-1);
      strip2.mirroredLoop = true;
      strip2.duration = 100;
      scene.add(strip2);

      var tri1G = new THREE.PlaneGeometry(20,5,L-1);
      for (var j = 0 ; j < L ; ++j) {
        tri1G.vertices[j].y = 5-5*j/L;
      }
      for ( ; j < 2*L ; ++j) {
        tri1G.vertices[j].y = 0;
      }
      var mvsR = midVs.slice();
      mvsR.reverse();
      var all_tvsR = topVs.slice();
      all_tvsR.reverse();
      wrapBetween(L,tri1G,all_tvsR,mvsR);
      var tri1M = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0xFF1166,morphTargets:true,polygonOffset:true,polygonOffsetFactor:1,polygonOffsetUnits:0.1} );
      var tri1 = new THREE.MorphAnimMesh(tri1G,tri1M);
      tri1.mirroredLoop = true;
      tri1.setFrameRange(2,L-1);
      tri1.duration = 100;
      //tri1.morphTargetInfluences = [];
      //for (var j = 0 ; j < L ; ++j) {
        //tri1.morphTargetInfluences[j] = 0;
      //}
      //tri1.morphTargetInfluences[L-1] = 1;
      //scene.add(tri1);

      var tri2G = new THREE.PlaneGeometry(20,5,L-1);
      for (var j = 0 ; j < L ; ++j) {
        tri2G.vertices[j].y = 5-5*j/L;
      }
      for ( ; j < 2*L ; ++j) {
        tri2G.vertices[j].y = 0;
      }
      wrapBetween(L,tri2G,bottomVs,midVs);
      var tri2M = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0xFF1166,morphTargets:true,polygonOffset:true,polygonOffsetFactor:1,polygonOffsetUnits:0.1} );
      var tri2 = new THREE.MorphAnimMesh(tri2G,tri2M);
      tri2.mirroredLoop = true;
      tri2.setFrameRange(2,L-1);
      tri2.duration = 100;
      //tri2.morphTargetInfluences = [];
      //for (var j = 0 ; j < L ; ++j) {
        //tri2.morphTargetInfluences[j] = 0;
      //}
      //tri2.morphTargetInfluences[L-1] = 1;
      //scene.add(tri2);

      /*
      var triG = new THREE.PlaneGeometry(20,5,2*L-1);
      console.log(topVs.concat(midVs).length);
      wrapBetween(2*L,triG,topVs.concat(bottomVs),midVs.concat(midVs));
      var triM = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x111166,morphTargets:true} );
      var tri = new THREE.Mesh(triG,triM);
      tri.morphTargetInfluences = [];
      for (var j = 0 ; j < L ; ++j) {
        tri.morphTargetInfluences[j] = 0;
      }
      //scene.add(tri);
      */

      var stage =1;
      var substage = 0;
      var nextstage = 0;
      var sq = true;

      render = function () {
        requestAnimationFrame(render);
        theta += 0.01;
        positionCamera();
        if (stage == 1 || stage == 2) {
          tri1.updateAnimation(1);
          tri2.updateAnimation(1);
          strip1.updateAnimation(1);
          strip2.updateAnimation(1);
          if (stage == 1 && strip1.time+1>strip1.duration) {
            stage = 0;
            substage = 0;
            nextstage = 2;
          } else if (stage == 2 && strip1.time-1<0) {
            stage = 0;
            substage = 0;
            nextstage = 1;
          }
        } else if (stage == 0) {
          substage++;
          if (substage == 50) {
            if (nextstage == 2) {
              if (sq) {
                sq = false;
                scene.remove(stripCut);
                scene.add(mid);
                scene.remove(strip1);
                scene.remove(strip2);
                scene.add(tri1);
                scene.add(tri2);
              } else {
                scene.add(stripCut);
                scene.remove(mid);
                sq = true;
                scene.add(strip1);
                scene.add(strip2);
                scene.remove(tri1);
                scene.remove(tri2);
              }
            }
          }
          if (substage == 100) {
            stage = nextstage;
          }
        } else if (stage == 3 || stage == 4) {
          tri1.updateAnimation(1);
          tri2.updateAnimation(1);
          if (stage == 3 && strip1.time+1>strip1.duration) {
            stage = 0;
            substage = 0;
            nextstage = 4;
          } else if (stage == 2 && strip1.time-1<0) {
            stage = 0;
            substage = 0;
            nextstage = 3;
          }
        }
        //strip2.updateAnimation(1);
        /*
        if (step < L-1) {
          strip.morphTargetInfluences[step] = 0;
          ++step;
          strip.morphTargetInfluences[step] = 1;
        } else if (step < L-2+100) {
          ++step;
        } else if (step == L-2+100) {
          scene.remove(strip);
          scene.add(tri);
          tri.morphTargetInfluences[2*L-1] = 1;
          ++step;
        } else if (step < L-2+100+2*L) {
          var j = step - (L-2+100);
          tri.morphTargetInfluences[2*L-j] = 0;
          ++step;
          ++j;
          tri.morphTargetInfluences[2*L-j] = 1;
        } else if (step < L-2+100+4*L) {
          var j = step - (L-2+100+2*L);
          tri.morphTargetInfluences[j] = 0;
          ++step;
          ++j;
          tri.morphTargetInfluences[j] = 1;
        }
        */

        /*
        } else {
          if (fwd) {
            if (step < 2*L-2) {
              if (step < 2*L-2) tri.morphTargetInfluences[step] = 0;
              ++step;
              if (step < 2*L-1) tri.morphTargetInfluences[step] = 1;
            } else {
              fwd = false;
            }
          } else {
            if (step > 2) {
              if (step < 2*L-1) tri.morphTargetInfluences[step] = 0;
              --step;
              if (step < 2*L-2) tri.morphTargetInfluences[step] = 1;
            } else {
              fwd = true;
            }
          }
        }
        */

        renderer.render(scene,camera);
      }


      /*
      L = 100;
      var stripG = new THREE.PlaneGeometry(20,5,L);
      console.log(stripG.vertices);
      console.log("#####");

      var cutG = new THREE.Geometry();
      var sVertices = [];

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10;
        var R = 10;
        sVertices[j] = new THREE.Vector3();
        sVertices[j+L+1] = new THREE.Vector3();
        sVertices[j].x = -r*Math.cos(Math.PI*j/L);
        sVertices[j].z = r*Math.sin(Math.PI*j/L);
        sVertices[j+L+1].x = -R*Math.cos(Math.PI*j/L);
        sVertices[j+L+1].z = R*Math.sin(Math.PI*j/L);
        sVertices[j].y = 2.5;
        sVertices[j+L+1].y = -2.5;
      }
      
      var vertices = [];

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10+2.5*Math.cos(Math.PI*j/L);
        var R = 10-2.5*Math.cos(Math.PI*j/L);
        vertices[j] = new THREE.Vector3();
        vertices[j+L+1] = new THREE.Vector3();
        vertices[j].x = -r*Math.cos(2*Math.PI*j/L);
        vertices[j].z = r*Math.sin(2*Math.PI*j/L);
        vertices[j+L+1].x = -R*Math.cos(2*Math.PI*j/L);
        vertices[j+L+1].z = R*Math.sin(2*Math.PI*j/L);
        vertices[j].y = 2.5*Math.sin(Math.PI*j/L);
        vertices[j+L+1].y = -2.5*Math.sin(Math.PI*j/L);
        cutG.vertices[j] = new THREE.Vector3();
        t = 1-j/(L+1);
        cutG.vertices[j].x = t*vertices[j].x + (1-t)*vertices[j+L+1].x;
        cutG.vertices[j].y = t*vertices[j].y + (1-t)*vertices[j+L+1].y;
        cutG.vertices[j].z = t*vertices[j].z + (1-t)*vertices[j+L+1].z;
      }

      var stripM = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x111166, morphTargets: true } );
      stripG.morphTargets[0] = { name:'target0',vertices:stripG.vertices};
      stripG.morphTargets[1] = { name:'target1',vertices:sVertices};
      stripG.morphTargets[2] = { name:'target2',vertices:vertices};
      var strip = new THREE.Mesh(stripG,stripM);
      //scene.add(strip);

      var triG = new THREE.PlaneGeometry(20,5,L);

      var ftVertices = []; //triG.vertices.slice();

      for (var j = 0 ; j < (L+1)/2 ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5+10*j/(L+1);
      }

      for ( ; j < L+1 ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5+10*(1-j/(L+1));
      }
      for ( ; j < 2*(L+1) ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5;
      }

      triG.morphTargets[0] = {name:'tri0',vertices:ftVertices.slice()};

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10+2.5*Math.cos(Math.PI*j/L);
        var R = 10-2.5*Math.cos(Math.PI*j/L);
        ftVertices[j] = ftVertices[j].clone();
        ftVertices[j+L+1] = ftVertices[j+L+1].clone();
        ftVertices[j].x = -R*Math.cos(2*Math.PI*j/(L+1))
        ftVertices[j].z = R*Math.sin(2*Math.PI*j/(L+1))
        ftVertices[j+L+1].x = -r*Math.cos(2*Math.PI*j/(L+1))
        ftVertices[j+L+1].z = r*Math.sin(2*Math.PI*j/(L+1))
      }
      triG.morphTargets[1] = {name:'tri1',vertices:ftVertices.slice()};

      for (var j = 0 ; j < (L+1)/2 ; ++j) {
        ftVertices[j] = cutG.vertices[2*j].clone();
      }

      for ( ; j < L+1 ; ++j) {
        ftVertices[j] = cutG.vertices[2*(j-(L+1)/2)].clone();
      }

      for ( ; j < 2*(L+1) ; ++j) {
        console.log(j-L-1);
        ftVertices[j] = vertices[2*(j-(L+1))].clone();
      }
      triG.morphTargets[2] = {name:'tri2',vertices:ftVertices.slice()};

      var triM = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x881166, morphTargets: true } );
      var tri = new THREE.Mesh(triG,triM);
      //tri.position = new THREE.Vector3 (0,0,0);
      scene.add(tri);
      //for (var j = 0 ; j < L+1 ; ++j) {
        //r = 10 + 2.5*j/L;
        //cutG.vertices[j] =  new THREE.Vector3(r*Math.cos(2*Math.PI*j/L),0,r*Math.sin(2*Math.PI*j/L));
      //}
      var cutM = new THREE.LineBasicMaterial( { linewidth: 14, color: 0xFF0000 });
      var cut = new THREE.Line (cutG, cutM);
      cut.position.set(0,0,0);
      //scene.add(cut);

      strip.morphTargetInfluences = [];
      strip.morphTargetInfluences[0] = 0;
      strip.morphTargetInfluences[1] = 0;
      strip.morphTargetInfluences[2] = 1;

      tri.morphTargetInfluences = [];
      tri.morphTargetInfluences[0] = 0;
      tri.morphTargetInfluences[1] = 1;
      tri.morphTargetInfluences[2] = 0;
      var fold = -2;

      render = function () {
        requestAnimationFrame(render);
        strip.rotation.x += 0.01;
        strip.rotation.z += 0.01;
        tri.rotation.x += 0.01;
        tri.rotation.z += 0.01;
        if (fold == -1) {
          tri.morphTargetInfluences[0] -= 0.01;
          tri.morphTargetInfluences[1] += 0.01;
          if (tri.morphTargetInfluences[1] >= 1) fold = 0;
        } else if (fold == 0) {
          tri.morphTargetInfluences[1] -= 0.01;
          tri.morphTargetInfluences[2] += 0.01;
          if (tri.morphTargetInfluences[2] >= 1) fold = 1;
        } else if (fold >= 1 && fold < 2) {
          fold += 0.01;
        } else if (fold >= 2 && fold < 3) {
          fold = 2;
          tri.morphTargetInfluences[1] += 0.01;
          tri.morphTargetInfluences[2] -= 0.01;
          if (tri.morphTargetInfluences[2] <= 0) fold = 3;
        } else if (fold == 3) {
          tri.morphTargetInfluences[0] += 0.01;
          tri.morphTargetInfluences[1] -= 0.01;
          if (tri.morphTargetInfluences[1] <= 0) fold = -1;
        }
        cut.rotation.x += 0.01;
        cut.rotation.z += 0.01;
        renderer.render(scene,camera);
      }
      */
      setTimeout(render,100);
    }

    window.onload = setup;
  </script>
  </head>
<body>
  <p>
    Möbius strips are awesome!
</p>
  <div id="animation-space">
  </div>

  <p><small>Don't see anything? Most likely your browser isn't set up for <a href="http://www.khronos.org/webgl/">WebGL</a>. Maybe <a href="http://get.webgl.org/">get.webgl.org</a> will be helpful. If you see the spinning cube on that website but don't see anything here, <a href="https://github.com/ajdunlap/visualizing-so3/issues">do complain</a>.</small></p>
  <hr />
  <p><small>Source available on <a href="https://github.com/ajdunlap/visualizing-so3">GitHub</a>. Created with <a href="http://threejs.org">three.js</a>. World map from <a href="http://commons.wikimedia.org/wiki/User:Koba-chan">User:Koba-chan</a> on <a href="https://commons.wikimedia.org/wiki/File:WorldMap-A_non-Frame.png">Wikimedia Commons</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA-3.0</a>.</small></p>
  <a href="http://www.w3.org/html/logo/">
<img src="http://www.w3.org/html/logo/badge/html5-badge-h-graphics.png" width="66" height="32" alt="HTML5 Powered with Graphics, 3D &amp; Effects" title="HTML5 Powered with Graphics, 3D &amp; Effects">
</a>
  </body>
</html>
