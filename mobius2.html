<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Möbius Strip</title>
    <style type="text/css">p,label { font-family: "Arial", "Liberation Sans", sans-serif; }</style>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="js/three.min.js"></script>

  <script type="text/javascript">
    function setup () {
      var width = 800;
      var height = 600;
  
      var scene = new THREE.Scene();
  
      var theta = 0;
      var camera = new THREE.PerspectiveCamera (3, width/height, 0.1, 5000);
      function positionCamera () {
        camera.position.z = 800*Math.cos(theta);
        camera.position.x = 800*Math.sin(theta);
        camera.position.y = 0;
        camera.lookAt(new THREE.Vector3(0,0,0));
      }
      positionCamera();
  
      var renderer = new THREE.WebGLRenderer();
      renderer.sortObjects = false;
      renderer.setSize(width,height);
      document.getElementById('animation-space').appendChild(renderer.domElement);

      var light = new THREE.AmbientLight( 0x404040 ); // soft white light
      scene.add( light );

      // Set up the light source
      var pointLight = new THREE.PointLight(0xFFFFFF);
      pointLight.position.x = 0;
      pointLight.position.y = 0;
      pointLight.position.z = 3000;
      scene.add(pointLight);
      var pointLight2 = new THREE.PointLight(0xFFFFFF);
      pointLight2.position.x = 0;
      pointLight2.position.y = 0;
      pointLight2.position.z = 0;
      scene.add(pointLight2);
      var pointLight3 = new THREE.PointLight(0xFFFFFF);
      pointLight3.position.x = 0;
      pointLight3.position.y = 0;
      pointLight3.position.z = -3000;
      scene.add(pointLight3);

      var L = 101;

      function wrapBetween (L, geom, topVs, bottomVs) {
        geom.morphTargets = [];
        vertices = geom.vertices.slice();
        for (var i = 0 ; i < L ; ++i) {
          if (i == 0) {
            vertices[i] = topVs[i];
            vertices[i+L] = bottomVs[i];
          } else {
            for (j = 0 ; j < 2*L ; ++j) {
              vertices[j] = vertices[j].clone();
            }
            var B = new THREE.Matrix4();
            var u = vertices[i];
            var v = vertices[i+L];
            var w = vertices[i-1];
            var uu = topVs[i];
            var vv = bottomVs[i];
            var ww = topVs[i-1];
            var A = new THREE.Matrix4(v.x-u.x,w.x-u.x,Math.random(),0,
                                      v.y-u.y,w.y-u.y,Math.random(),0,
                                      v.z-u.z,w.z-u.z,Math.random(),0,
                                      0,0,0,1
                                      );
            var B = new THREE.Matrix4(vv.x-uu.x,ww.x-uu.x,Math.random(),0,
                                      vv.y-uu.y,ww.y-uu.y,Math.random(),0,
                                      vv.z-uu.z,ww.z-uu.z,Math.random(),0,
                                      0,0,0,1
                                      );
            var Ainv = new THREE.Matrix4();
            Ainv.getInverse(A);
            var C = new THREE.Matrix4();
            C.multiplyMatrices(B,Ainv);
            var uuu = u.clone();
            uuu.applyMatrix4(C);
            var D = new THREE.Matrix4();
            D.makeTranslation(uu.x-uuu.x,uu.y-uuu.y,uu.z-uuu.z);
            var E = new THREE.Matrix4();
            E.multiplyMatrices(D,C);
  
            for (var j = i ; j < L ; ++j) {
              vertices[j].applyMatrix4(E);
              vertices[j+L].applyMatrix4(E);
            }
          }
          geom.morphTargets[i] = {name:'v'+i,vertices:vertices.slice()};
        }
          
        //for (var j = 0 ; j < L ; j++) {
          //geom.vertices[j] = topVs[j];
        //}
        //for ( ; j < 2*L ; ++j) {
          //geom.vertices[j] = bottomVs[j-L];
        //}
        //var vertices = geom.vertices.slice();
        //for (var i = 0 ; i < L ; ++i) {
          //for (var j = 0 ; j < L ; ++j) {
            //
          //}
        //}
      }

      var topVs = [];
      var bottomVs = [];
      var midVs = [];
      for (var j = 0 ; j < L ; ++j) {
        var r = 10-2.5*Math.cos(Math.PI*j/(L-1));
        var R = 10+2.5*Math.cos(Math.PI*j/(L-1));
        topVs[j] = new THREE.Vector3(R*Math.cos(2*Math.PI*j/(L-1)),
        R*Math.sin(2*Math.PI*j/(L-1)),
        2.5*Math.sin(Math.PI*j/(L-1)));
      bottomVs[j] = new THREE.Vector3(r*Math.cos(2*Math.PI*j/(L-1)),
      r*Math.sin(2*Math.PI*j/(L-1)),
      -2.5*Math.sin(Math.PI*j/(L-1)));
    var tmp = topVs[j].clone();
    tmp.multiplyScalar(1-j/(L-1));
    midVs[j] = bottomVs[j].clone();
    midVs[j].multiplyScalar(j/(L-1));
    midVs[j].add(tmp);
      }

      var topG = new THREE.Geometry();
      topG.vertices = topVs;
      var topM = new THREE.LineBasicMaterial({color:0xFF0000,linewidth:4});
      var topp = new THREE.Line(topG,topM);
      scene.add(topp);

      var bottomG = new THREE.Geometry();
      bottomG.vertices = bottomVs;
      var bottomM = new THREE.LineBasicMaterial({color:0x00FF00,linewidth:4});
      var bottom = new THREE.Line(bottomG,bottomM);
      scene.add(bottom);

      var midG = new THREE.Geometry();
      midG.vertices = midVs;
      var midM = new THREE.LineBasicMaterial({color:0x0000FF,linewidth:4});
      var mid = new THREE.Line(midG,midM);
      scene.add(mid);

      var stripG = new THREE.PlaneGeometry(20,5,L-1);
      wrapBetween(L,stripG,topVs,bottomVs);
      var stripM = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x111166,morphTargets:true} );
      var strip = new THREE.Mesh(stripG,stripM);
      strip.morphTargetInfluences = [];
      for (var j = 0 ; j < L ; ++j) {
        strip.morphTargetInfluences[j] = 0;
      }
      scene.add(strip);
      var step = 0;
      var fwd = true;

      render = function () {
        requestAnimationFrame(render);
        theta += 0.01;
        positionCamera();
        if (fwd) {
          if (step < 200) {
            if (step < 100) strip.morphTargetInfluences[step] = 0;
            ++step;
            if (step < 101) strip.morphTargetInfluences[step] = 1;
          } else {
            fwd = false;
          }
        } else {
          if (step > 2) {
            if (step < 101) strip.morphTargetInfluences[step] = 0;
            --step;
            if (step < 100) strip.morphTargetInfluences[step] = 1;
          } else {
            fwd = true;
          }
        }
        //strip.rotation.x += 0.01;
        renderer.render(scene,camera);
      }


      /*
      L = 100;
      var stripG = new THREE.PlaneGeometry(20,5,L);
      console.log(stripG.vertices);
      console.log("#####");

      var cutG = new THREE.Geometry();
      var sVertices = [];

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10;
        var R = 10;
        sVertices[j] = new THREE.Vector3();
        sVertices[j+L+1] = new THREE.Vector3();
        sVertices[j].x = -r*Math.cos(Math.PI*j/L);
        sVertices[j].z = r*Math.sin(Math.PI*j/L);
        sVertices[j+L+1].x = -R*Math.cos(Math.PI*j/L);
        sVertices[j+L+1].z = R*Math.sin(Math.PI*j/L);
        sVertices[j].y = 2.5;
        sVertices[j+L+1].y = -2.5;
      }
      
      var vertices = [];

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10+2.5*Math.cos(Math.PI*j/L);
        var R = 10-2.5*Math.cos(Math.PI*j/L);
        vertices[j] = new THREE.Vector3();
        vertices[j+L+1] = new THREE.Vector3();
        vertices[j].x = -r*Math.cos(2*Math.PI*j/L);
        vertices[j].z = r*Math.sin(2*Math.PI*j/L);
        vertices[j+L+1].x = -R*Math.cos(2*Math.PI*j/L);
        vertices[j+L+1].z = R*Math.sin(2*Math.PI*j/L);
        vertices[j].y = 2.5*Math.sin(Math.PI*j/L);
        vertices[j+L+1].y = -2.5*Math.sin(Math.PI*j/L);
        cutG.vertices[j] = new THREE.Vector3();
        t = 1-j/(L+1);
        cutG.vertices[j].x = t*vertices[j].x + (1-t)*vertices[j+L+1].x;
        cutG.vertices[j].y = t*vertices[j].y + (1-t)*vertices[j+L+1].y;
        cutG.vertices[j].z = t*vertices[j].z + (1-t)*vertices[j+L+1].z;
      }

      var stripM = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x111166, morphTargets: true } );
      stripG.morphTargets[0] = { name:'target0',vertices:stripG.vertices};
      stripG.morphTargets[1] = { name:'target1',vertices:sVertices};
      stripG.morphTargets[2] = { name:'target2',vertices:vertices};
      var strip = new THREE.Mesh(stripG,stripM);
      //scene.add(strip);

      var triG = new THREE.PlaneGeometry(20,5,L);

      var ftVertices = []; //triG.vertices.slice();

      for (var j = 0 ; j < (L+1)/2 ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5+10*j/(L+1);
      }

      for ( ; j < L+1 ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5+10*(1-j/(L+1));
      }
      for ( ; j < 2*(L+1) ; ++j) {
        ftVertices[j] = triG.vertices[j].clone();
        ftVertices[j].y = -2.5;
      }

      triG.morphTargets[0] = {name:'tri0',vertices:ftVertices.slice()};

      for (var j = 0 ; j < L+1 ; ++j) {
        var r = 10+2.5*Math.cos(Math.PI*j/L);
        var R = 10-2.5*Math.cos(Math.PI*j/L);
        ftVertices[j] = ftVertices[j].clone();
        ftVertices[j+L+1] = ftVertices[j+L+1].clone();
        ftVertices[j].x = -R*Math.cos(2*Math.PI*j/(L+1))
        ftVertices[j].z = R*Math.sin(2*Math.PI*j/(L+1))
        ftVertices[j+L+1].x = -r*Math.cos(2*Math.PI*j/(L+1))
        ftVertices[j+L+1].z = r*Math.sin(2*Math.PI*j/(L+1))
      }
      triG.morphTargets[1] = {name:'tri1',vertices:ftVertices.slice()};

      for (var j = 0 ; j < (L+1)/2 ; ++j) {
        ftVertices[j] = cutG.vertices[2*j].clone();
      }

      for ( ; j < L+1 ; ++j) {
        ftVertices[j] = cutG.vertices[2*(j-(L+1)/2)].clone();
      }

      for ( ; j < 2*(L+1) ; ++j) {
        console.log(j-L-1);
        ftVertices[j] = vertices[2*(j-(L+1))].clone();
      }
      triG.morphTargets[2] = {name:'tri2',vertices:ftVertices.slice()};

      var triM = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x881166, morphTargets: true } );
      var tri = new THREE.Mesh(triG,triM);
      //tri.position = new THREE.Vector3 (0,0,0);
      scene.add(tri);
      //for (var j = 0 ; j < L+1 ; ++j) {
        //r = 10 + 2.5*j/L;
        //cutG.vertices[j] =  new THREE.Vector3(r*Math.cos(2*Math.PI*j/L),0,r*Math.sin(2*Math.PI*j/L));
      //}
      var cutM = new THREE.LineBasicMaterial( { linewidth: 14, color: 0xFF0000 });
      var cut = new THREE.Line (cutG, cutM);
      cut.position.set(0,0,0);
      //scene.add(cut);

      strip.morphTargetInfluences = [];
      strip.morphTargetInfluences[0] = 0;
      strip.morphTargetInfluences[1] = 0;
      strip.morphTargetInfluences[2] = 1;

      tri.morphTargetInfluences = [];
      tri.morphTargetInfluences[0] = 0;
      tri.morphTargetInfluences[1] = 1;
      tri.morphTargetInfluences[2] = 0;
      var fold = -2;

      render = function () {
        requestAnimationFrame(render);
        strip.rotation.x += 0.01;
        strip.rotation.z += 0.01;
        tri.rotation.x += 0.01;
        tri.rotation.z += 0.01;
        if (fold == -1) {
          tri.morphTargetInfluences[0] -= 0.01;
          tri.morphTargetInfluences[1] += 0.01;
          if (tri.morphTargetInfluences[1] >= 1) fold = 0;
        } else if (fold == 0) {
          tri.morphTargetInfluences[1] -= 0.01;
          tri.morphTargetInfluences[2] += 0.01;
          if (tri.morphTargetInfluences[2] >= 1) fold = 1;
        } else if (fold >= 1 && fold < 2) {
          fold += 0.01;
        } else if (fold >= 2 && fold < 3) {
          fold = 2;
          tri.morphTargetInfluences[1] += 0.01;
          tri.morphTargetInfluences[2] -= 0.01;
          if (tri.morphTargetInfluences[2] <= 0) fold = 3;
        } else if (fold == 3) {
          tri.morphTargetInfluences[0] += 0.01;
          tri.morphTargetInfluences[1] -= 0.01;
          if (tri.morphTargetInfluences[1] <= 0) fold = -1;
        }
        cut.rotation.x += 0.01;
        cut.rotation.z += 0.01;
        renderer.render(scene,camera);
      }
      */
      setTimeout(render,100);
    }

    window.onload = setup;
  </script>
  </head>
<body>
  <p>
    Möbius strips are awesome!
</p>
  <div id="animation-space">
  </div>

  <p><small>Don't see anything? Most likely your browser isn't set up for <a href="http://www.khronos.org/webgl/">WebGL</a>. Maybe <a href="http://get.webgl.org/">get.webgl.org</a> will be helpful. If you see the spinning cube on that website but don't see anything here, <a href="https://github.com/ajdunlap/visualizing-so3/issues">do complain</a>.</small></p>
  <hr />
  <p><small>Source available on <a href="https://github.com/ajdunlap/visualizing-so3">GitHub</a>. Created with <a href="http://threejs.org">three.js</a>. World map from <a href="http://commons.wikimedia.org/wiki/User:Koba-chan">User:Koba-chan</a> on <a href="https://commons.wikimedia.org/wiki/File:WorldMap-A_non-Frame.png">Wikimedia Commons</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA-3.0</a>.</small></p>
  <a href="http://www.w3.org/html/logo/">
<img src="http://www.w3.org/html/logo/badge/html5-badge-h-graphics.png" width="66" height="32" alt="HTML5 Powered with Graphics, 3D &amp; Effects" title="HTML5 Powered with Graphics, 3D &amp; Effects">
</a>
  </body>
</html>
